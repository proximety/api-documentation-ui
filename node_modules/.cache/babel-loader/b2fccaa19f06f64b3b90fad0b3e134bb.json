{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport var rowsMetaStateInitializer = function rowsMetaStateInitializer(state) {\n  return _extends({}, state, {\n    rowsMeta: {\n      currentPageTotalHeight: 0,\n      positions: []\n    }\n  });\n};\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport var useGridRowsMeta = function useGridRowsMeta(apiRef, props) {\n  var getRowHeightProp = props.getRowHeight,\n      getRowSpacing = props.getRowSpacing,\n      getEstimatedRowHeight = props.getEstimatedRowHeight;\n  var rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  var lastMeasuredRowIndex = React.useRef(-1);\n  var hasRowWithAutoHeight = React.useRef(false);\n  var rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  var filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  var paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  var sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  var hydrateRowsMeta = React.useCallback(function () {\n    var _pinnedRows$top, _pinnedRows$bottom;\n\n    hasRowWithAutoHeight.current = false;\n    var densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n\n    var calculateRowProcessedSizes = function calculateRowProcessedSizes(row) {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            base: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n        };\n      }\n\n      var _rowsHeightLookup$cur3 = rowsHeightLookup.current[row.id],\n          isResized = _rowsHeightLookup$cur3.isResized,\n          needsFirstMeasurement = _rowsHeightLookup$cur3.needsFirstMeasurement,\n          sizes = _rowsHeightLookup$cur3.sizes;\n      var baseRowHeight = rowHeightFromDensity;\n      var existingBaseRowHeight = sizes.base;\n\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        var rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor: densityFactor\n        }));\n\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            var estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor: densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      } // We use an object to make simple to check if a height is already added or not\n\n\n      var initialHeights = {\n        base: baseRowHeight\n      };\n\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n\n        var indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        var spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage: indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n\n      var processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n\n    var positions = [];\n    var currentPageTotalHeight = currentPage.rows.reduce(function (acc, row) {\n      positions.push(acc);\n      var processedSizes = calculateRowProcessedSizes(row);\n      var finalRowHeight = Object.values(processedSizes).reduce(function (acc2, value) {\n        return acc2 + value;\n      }, 0);\n      return acc + finalRowHeight;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(function (row) {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(function (row) {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight: currentPageTotalHeight,\n          positions: positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  var getRowHeight = React.useCallback(function (rowId) {\n    var height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.base : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  var getRowInternalSizes = function getRowInternalSizes(rowId) {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  var setRowHeight = React.useCallback(function (id, height) {\n    rowsHeightLookup.current[id].sizes.base = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  var debouncedHydrateRowsMeta = React.useMemo(function () {\n    return debounce(hydrateRowsMeta);\n  }, [hydrateRowsMeta]);\n  var storeMeasuredRowHeight = React.useCallback(function (id, height) {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    var needsHydration = rowsHeightLookup.current[id].sizes.base !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes.base = height;\n\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  var rowHasAutoHeight = React.useCallback(function (id) {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  var getLastMeasuredRowIndex = React.useCallback(function () {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  var setLastMeasuredRowIndex = React.useCallback(function (index) {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(function () {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  var rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};","map":{"version":3,"names":["_extends","React","debounce","useGridVisibleRows","useGridApiMethod","useGridSelector","gridDensityRowHeightSelector","gridDensityFactorSelector","gridFilterStateSelector","gridPaginationSelector","gridSortingStateSelector","useGridRegisterPipeApplier","gridPinnedRowsSelector","rowsMetaStateInitializer","state","rowsMeta","currentPageTotalHeight","positions","useGridRowsMeta","apiRef","props","getRowHeightProp","getRowHeight","getRowSpacing","getEstimatedRowHeight","rowsHeightLookup","useRef","lastMeasuredRowIndex","hasRowWithAutoHeight","rowHeightFromDensity","filterState","paginationState","sortingState","currentPage","pinnedRows","hydrateRowsMeta","useCallback","_pinnedRows$top","_pinnedRows$bottom","current","densityFactor","instanceId","calculateRowProcessedSizes","row","id","sizes","base","isResized","autoHeight","needsFirstMeasurement","baseRowHeight","existingBaseRowHeight","rowHeightFromUser","estimatedRowHeight","initialHeights","_spacing$top","_spacing$bottom","indexRelativeToCurrentPage","getRowIndexRelativeToVisibleRows","spacing","isFirstVisible","isLastVisible","rows","length","spacingTop","top","spacingBottom","bottom","processedSizes","unstable_applyPipeProcessors","reduce","acc","push","finalRowHeight","Object","values","acc2","value","forEach","setState","Infinity","forceUpdate","rowId","height","getRowInternalSizes","_rowsHeightLookup$cur","setRowHeight","debouncedHydrateRowsMeta","useMemo","storeMeasuredRowHeight","needsHydration","rowHasAutoHeight","_rowsHeightLookup$cur2","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","useEffect","rowsMetaApi","unstable_getLastMeasuredRowIndex","unstable_setLastMeasuredRowIndex","unstable_rowHasAutoHeight","unstable_getRowHeight","unstable_getRowInternalSizes","unstable_setRowHeight","unstable_storeRowHeightMeasurement"],"sources":["C:/Users/luluf/OneDrive/Documents/Proximety/api-documentation-ui/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowsMeta.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { debounce } from '@mui/material/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityRowHeightSelector, gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterStateSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortingStateSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nexport const rowsMetaStateInitializer = state => _extends({}, state, {\n  rowsMeta: {\n    currentPageTotalHeight: 0,\n    positions: []\n  }\n});\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\n\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const rowsHeightLookup = React.useRef({}); // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const rowHeightFromDensity = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  const filterState = useGridSelector(apiRef, gridFilterStateSelector);\n  const paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const hydrateRowsMeta = React.useCallback(() => {\n    var _pinnedRows$top, _pinnedRows$bottom;\n\n    hasRowWithAutoHeight.current = false;\n    const densityFactor = gridDensityFactorSelector(apiRef.current.state, apiRef.current.instanceId);\n\n    const calculateRowProcessedSizes = row => {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            base: rowHeightFromDensity\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n\n        };\n      }\n\n      const {\n        isResized,\n        needsFirstMeasurement,\n        sizes\n      } = rowsHeightLookup.current[row.id];\n      let baseRowHeight = rowHeightFromDensity;\n      const existingBaseRowHeight = sizes.base;\n\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor\n        }));\n\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor\n            })) : rowHeightFromDensity; // If the row was not measured yet use the estimated row height\n\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeightFromDensity;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns null or undefined.\n          baseRowHeight = rowHeightFromUser != null ? rowHeightFromUser : rowHeightFromDensity;\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      } // We use an object to make simple to check if a height is already added or not\n\n\n      const initialHeights = {\n        base: baseRowHeight\n      };\n\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n\n        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        const spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n\n      const processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      const processedSizes = calculateRowProcessedSizes(row);\n      const finalRowHeight = Object.values(processedSizes).reduce((acc2, value) => acc2 + value, 0);\n      return acc + finalRowHeight;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(row => {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight,\n          positions\n        }\n      });\n    });\n\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeightFromDensity, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows]);\n  const getRowHeight = React.useCallback(rowId => {\n    const height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.base : rowHeightFromDensity;\n  }, [rowHeightFromDensity]);\n\n  const getRowInternalSizes = rowId => {\n    var _rowsHeightLookup$cur;\n\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n\n  const setRowHeight = React.useCallback((id, height) => {\n    rowsHeightLookup.current[id].sizes.base = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const debouncedHydrateRowsMeta = React.useMemo(() => debounce(hydrateRowsMeta), [hydrateRowsMeta]);\n  const storeMeasuredRowHeight = React.useCallback((id, height) => {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    } // Only trigger hydration if the value is different, otherwise we trigger a loop\n\n\n    const needsHydration = rowsHeightLookup.current[id].sizes.base !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes.base = height;\n\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  const rowHasAutoHeight = React.useCallback(id => {\n    var _rowsHeightLookup$cur2;\n\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  const getLastMeasuredRowIndex = React.useCallback(() => {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  const setLastMeasuredRowIndex = React.useCallback(index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []); // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n\n  React.useEffect(() => {\n    hydrateRowsMeta();\n  }, [rowHeightFromDensity, filterState, paginationState, sortingState, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  const rowsMetaApi = {\n    unstable_getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_rowHasAutoHeight: rowHasAutoHeight,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'GridRowsMetaApi');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}